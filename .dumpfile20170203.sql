-- MySQL dump 10.13  Distrib 5.7.16, for Linux (x86_64)
--
-- Host: localhost    Database: test
-- ------------------------------------------------------
-- Server version	5.7.16-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `Grading`
--

DROP TABLE IF EXISTS `Grading`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Grading` (
  `ID` int(64) NOT NULL AUTO_INCREMENT,
  `submissionID` int(64) DEFAULT NULL,
  `result` int(64) DEFAULT NULL,
  PRIMARY KEY (`ID`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Grading`
--

LOCK TABLES `Grading` WRITE;
/*!40000 ALTER TABLE `Grading` DISABLE KEYS */;
/*!40000 ALTER TABLE `Grading` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Submission`
--

DROP TABLE IF EXISTS `Submission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Submission` (
  `ID` int(64) NOT NULL AUTO_INCREMENT,
  `userID` int(64) DEFAULT NULL,
  `taskID` int(64) DEFAULT NULL,
  `content` text,
  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `judgeSubmissionID` text,
  PRIMARY KEY (`ID`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Submission`
--

LOCK TABLES `Submission` WRITE;
/*!40000 ALTER TABLE `Submission` DISABLE KEYS */;
INSERT INTO `Submission` VALUES (1,1,1,'blabluabklkak','2017-01-27 11:02:18','123'),(2,1,1,'blabluabklkak','2017-01-27 12:14:28','123'),(3,1,3,'theory Submission\nimports Defs\nbegin\n\n(* this is the submission file,\nthat\'s the file you should edit, and the place where you should compose the proofs that we\nasked for!\n\n*)\nend \n','2017-01-27 16:15:24',''),(4,1,3,'theory Submission\nimports Defs\nbegin\n\n(* this is the submission file,\nthat\'s the file you should edit, and the place where you should compose the proofs that we\nasked for!\n\n*)\nend \n','2017-01-27 16:16:49','50'),(5,1,3,'theory Submission\nimports Defs\nbegin\n\nlemma \"True\" by simp\n(* this is the submission file,\nthat\'s the file you should edit, and the place where you should compose the proofs that we\nasked for!\n\n*)\n\nlemma \"True\" by simp\n\nend \n','2017-01-27 16:17:58','51'),(6,1,4,'theory Submission\nimports Defs\nbegin\n\n\nthm world_def\nthm hello.simps\n\nvalue \"hello 0\"\nvalue \"hello (Suc n)\"\nvalue \"world\" (* the definition of world will not be unfolded automatically! *)\nvalue \"1 + 1\" (* it is ambiguous what 1, and plus means, that\'s why no value could be determined *)\nvalue \"1 + (1::nat)\" (* when annotateing the type nat, the result can be determined *)\n\n\nlemma helloworld: \"hello world\" unfolding world_def by simp\n\nend\n','2017-02-02 11:35:27','52'),(7,1,7,'theory Submission\n  imports Defs\nbegin\n\n\nthm nat.induct\n\nlemma \"add m 0 = m\"\napply(induct m) by (auto)\n\nlemma add_nm: \"add n m = n + m\"\napply(induct n) by (auto)\n\n\n\nend','2017-02-02 12:16:56','53'),(8,1,7,'theory Submission\n  imports Defs\nbegin\n\n\nthm nat.induct\n\nlemma \"add m 0 = m\"\napply(induct m) by (auto)\n\nlemma add_nm: \"add n m = n + m\"\napply(induct n) by (auto)\n\n\n\nend','2017-02-02 12:18:12','54'),(9,1,8,'theory Submission\n  imports Defs\nbegin\n\n\nthm nat.induct\n\nlemma add_m0: \"add m 0 = m\"\napply(induct m) by (auto)\n\nlemma add_nm: \"add n m = n + m\"\napply(induct n) by (auto)\n\nlemma Suc_add: \"Suc (add m n) = add m (Suc n)\"\napply(induct m) apply(simp) apply(simp) done\n\nlemma add_commutes: \"add n m = add m n\"\napply(induct n) apply(simp add: add_m0)\napply simp\napply (simp add:   Suc_add) done\n\n\nend','2017-02-02 12:49:36','55'),(10,1,9,'theory Submission\n  imports Defs\nbegin\n\n\nfun rev where\n    \"rev (x#xs) = rev xs @ [x]\"\n  | \"rev [] = []\"\n  \n  \nlemma rev_append: \"rev (xs @ ys) = rev ys @ rev xs\"\n  apply(induct xs) by(auto)\n  \nlemma doublerev: \"rev (rev xs) = xs\"\n  apply(induct xs) by(auto simp: rev_append)\n\n\nend','2017-02-03 10:36:38','56'),(11,1,9,'theory Submission\n  imports Defs\nbegin\n\n\n  declare [[names_short]]\n  \n  \nlemma app_Nil2 [simp]: \"app xs Nil = xs\"\napply(induction xs) apply(auto) done\n  \n\nlemma app_assoc [simp]: \"app (app xs ys) zs = app xs (app ys zs)\"\napply(induction xs) apply(auto) done\n\nlemma rev_append [simp]: \"rev (app xs ys) = app (rev ys) (rev xs)\"\n  apply(induct xs) apply(auto) done\n  \nlemma doublerev: \"rev (rev xs) = xs\"\n  apply(induct xs) apply auto  done\n\n\nend','2017-02-03 10:37:25','57'),(12,1,9,'theory Submission\n  imports Defs\nbegin\n\n\n  declare [[names_short]]\n  \n  \nlemma app_Nil2 [simp]: \"app xs Nil = xs\"\napply(induction xs) apply(auto) done\n  \n\nlemma app_assoc [simp]: \"app (app xs ys) zs = app xs (app ys zs)\"\napply(induction xs) apply(auto) done\n\nlemma rev_append [simp]: \"rev (app xs ys) = app (rev ys) (rev xs)\"\n  apply(induct xs) apply(auto) done\n  \nlemma doublerev: \"rev (rev xs) = xs\"\n  apply(induct xs) apply auto  done\n\n\nend','2017-02-03 10:38:19','58'),(13,1,9,'theory Submission\n  imports Defs\nbegin\n\n\n  declare [[names_short]]\n  \n  \nlemma app_Nil2 [simp]: \"app xs Nil = xs\"\napply(induction xs) apply(auto) done\n  \n\nlemma app_assoc [simp]: \"app (app xs ys) zs = app xs (app ys zs)\"\napply(induction xs) apply(auto) done\n\nlemma rev_append [simp]: \"rev (app xs ys) = app (rev ys) (rev xs)\"\n  apply(induct xs) apply(auto) done\n  \nlemma doublerev: \"rev (rev xs) = xs\"\n  apply(induct xs) apply auto  done\n\n\nend','2017-02-03 13:21:21','59'),(14,1,10,'theory Submission\n  imports Defs\nbegin\n\n\nfun rev where\n    \"rev (x#xs) = rev xs @ [x]\"\n  | \"rev [] = []\"\n  \n  \nlemma rev_append: \"rev (xs @ ys) = rev ys @ rev xs\"\n  apply(induct xs) by(auto)\n  \nlemma doublerev: \"rev (rev xs) = xs\"\n  apply(induct xs) by(auto simp: rev_append)\n\n\nend','2017-02-03 13:35:06','60'),(15,1,11,'theory Submission\n  imports Defs\nbegin\n\n\nfun count :: \"\'a \\<Rightarrow> \'a list \\<Rightarrow> nat\" where\n    \"count z (x#xs) = (if x = z then 1 + count z xs else count z xs)\"\n  | \"count _ [] = 0\"\n  \nlemma count_ub: \"count x xs \\<le> length xs\"\napply(induct xs) by auto\n\nend','2017-02-03 13:46:21','61'),(16,1,12,'theory Submission\n  imports Defs\nbegin\n\nlemma add_assoc: \"add (add x y) z= add x (add y z)\"\napply(induct x)\napply(auto) done\n\nend','2017-02-03 14:00:08','62');
/*!40000 ALTER TABLE `Submission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Task`
--

DROP TABLE IF EXISTS `Task`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Task` (
  `ID` int(64) NOT NULL AUTO_INCREMENT,
  `name` text,
  `judgeTaskID` text,
  `description` text,
  `checkthy` text,
  `defthy` text,
  `contest` text,
  `subthy` text,
  PRIMARY KEY (`ID`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Task`
--

LOCK TABLES `Task` WRITE;
/*!40000 ALTER TABLE `Task` DISABLE KEYS */;
INSERT INTO `Task` VALUES (1,'mod9','mod9','In this task you have to do some crazy stuff!','Check','Definition','helloworld','Submission'),(2,'name2','trivial','Rev! In this task you have to do some real stuff!','Check2asdasdasd','Definition2','tutorial','Submission'),(3,'Install Isabelle','1','This is the first Task you get assigned. \r\n\r\nWe will guide you through the (quite easy) installation of Isabelle and explain how you can submit your solution to the Task in the end.\r\n\r\n<h2>In this task you will learn:</h2>\r\n<ul>\r\n<li>how to install isabelle</li>\r\n<li>how to manage theories for this tutorial</li>\r\n<li>how to submit solutions</li>\r\n</ul>\r\n\r\n<h2>Introduction</h2>\r\n\r\nThis Tutorial is based on the first Chapter of Part I of the book \"Concrete Semantics\" by Tobias Nipkow and Gerwin Klein, which is freely available as pdf <a href=\"http://concrete-semantics.org/\">here</a>.\r\n\r\nIsabelle is a generic system for implementing logical formalisms, and Isabelle/HOL is the specialization of Isabelle for HOL, which abbreviates Higher-\r\nOrder Logic. We introduce HOL step by step following the equation\r\n\r\nHOL = Functional Programming + Logic\r\n\r\nWe assume that the reader is used to logical and set-theoretic notation and is familiar with the basic concepts of functional programming.\r\n\r\nThis introduction to the core of Isabelle is intentionally concrete and example-based: we concentrate on examples that illustrate the typical cases\r\nwithout explaining the general case if it can be inferred from the examples. We cover the essentials (from a functional programming point of view) as quickly\r\nand compactly as possible. After all, this book is primarily about semantics.\r\n\r\nFor a comprehensive treatment of Isabelle we recommend the <a href=\"http://isabelle.in.tum.de/doc/isar-ref.pdf\">Isabelle/Isar Reference Manual</a>, which comes with the Isabelle distribution. The <a href=\"http://isabelle.in.tum.de/dist/Isabelle2016-1/doc/tutorial.pdf\">tutorial</a> by Nipkow, Paulson and Wenzel (in its updated version that comes with the Isabelle distribution) is still recommended for the wealth of examples and material, but its proof style is outdated. In particular it does not cover the structured proof language Isar.\r\n\r\n<h2>Getting Started with Isabelle</h2>\r\n\r\nIf you have not done so already, download and install Isabelle (this tutorial is compatible with Isabelle2016-1) from <a href=\"http://isabelle.in.tum.de\">http://isabelle.in.tum.de</a>. You can start it by clicking on the application icon. This will launch Isabelle\'s user interface based on the text editor jEdit.\r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>First startup of Isabelle will build the library, which may take a while.</td>\r\n</tr>\r\n</table>\r\n\r\nBelow you see a typical example snapshot of a session. At this point we merely explain the layout of the window, not its contents.\r\n\r\n<center><img src=\"img/IsabelleJEdit.png\"></center>\r\n\r\nThe upper part of the window shows the input typed by the user, i.e., the gradually growing Isabelle text of definitions, theorems, proofs, etc. The interface processes the user input automatically while it is typed, just like modern Java IDEs. Isabelle?s response to the user input is shown in the lower part of the window. You can examine the response to any input phrase by clicking on that phrase or by hovering over underlined text.\r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>This tutorial frequently refers to the proof state. You can see the proof state if you change to the \"State\" tab. If you want to see the proof state combined with other system output, use the \"Output\" tab and tick the \"Proof state\" box. (The latter option is suggested by the author)</td>\r\n</tr>\r\n</table>\r\n\r\nThis should suffice to get started with the jEdit interface. Now you need\r\nto learn what to type into it.\r\n\r\n\r\n<h2>Theories</h2>\r\n\r\nRoughly speaking, a <b>theory</b> is a named collection of types, functions, and theorems, much like a module in a programming language. All Isabelle text needs to go into a theory. The general format of a theory <i>T</i> is\r\n\r\n<center>\r\n<table>\r\n<tr>\r\n<td>\r\n<b>theory</b> T<br>\r\n<b>imports</b> T1 ... Tn<br>\r\n<b>begin</b><br>\r\n<i>definitions, theorems and proofs</i><br>\r\n<b>end</b><br>\r\n</td>\r\n</tr>\r\n</table>\r\n</center>\r\n\r\nwhere <i>T1 ... Tn</i> are the names of existing theories that <i>T</i> is based on. The <i>Ti</i> are the direct parent theories of T. Everything defined in the parent theories (and their parents, recursively) is automatically visible. Each theory T must reside in a theory file named T.thy.\r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>HOL contains a theory <i>Main</i>, the union of all the basic predefined theories like arithmetic, lists, sets, etc. Unless you know what you are doing, always include <i>Main</i> as a direct or indirect parent of all your theories.</td>\r\n</tr>\r\n</table>\r\n\r\nIn addition to the theories that come with the Isabelle/HOL distribution (see <a href=\"http://isabelle.in.tum.de/library/HOL\">http://isabelle.in.tum.de/library/HOL</a>) there is also the Archive of Formal Proofs at <a href=\"http://afp.sourceforge.net\">http://afp.sourceforge.net</a>, a growing collection of Isabelle theories that everybody can contribute to.\r\n\r\n\r\n<h2>First Lesson</h2>\r\n\r\nEach Lesson of this tutorial will consist of two things: first a new topic with explanations like the above, and second a task to write some theory.\r\n\r\nThe theory you will develop always consists of three files:\r\n<ul>\r\n<li><b>Defs.thy</b><br>\r\nAll imports that are needed and definitions that are made in the task will reside in<br>\r\nthat file. You should neither edit it nor upload it within your submission. The definitions<br>\r\nare known to the judge.\r\n</li>\r\n<li><b>Submission.thy</b><br>\r\nThis file imports the theory Defs and all of your definitions and proofs should reside in here.<br>\r\nUsually you will be given some sort of template where the lemma that has to be proven is already<br>\r\ngiven. <br>\r\nEdit this File, and submit it afterwards.\r\n</li>\r\n<li><b>Check.thy</b><br>\r\nThis file will import your Submission. It checks whether the \r\n<br>\r\nNeither edit this file nor include it into your submission!\r\n</li>\r\n</ul>\r\n\r\nThe content of this files will allways be presented at the end of the lesson\'s page.\r\nAfter solving the Task, you have to upload the Submission.thy.\r\n\r\n<h3>Your first Task</h3>\r\n\r\nWe recommend that you create a new folder called \"1\" with three files, named Defs.thy, Submission.thy and Check.thy.\r\nOpen those three files with Isabelle/JEdit and fill in the respective contents.\r\n\r\nIn the files you can learn how to \r\n\r\n\r\nThen upload the Submission.thy; It should be a valid theory file, which imports Defs.\r\n\r\nGood Luck ;) and see you for the next Lesson!\r\n','theory Check\r\nimports Submission\r\nbegin\r\n\r\n(* this is the Check file, \r\n   it is used in order to check, whether you proved the asked stuff correctly\r\n*)\r\n\r\n\r\nend','theory Defs\r\n  imports Main\r\nbegin\r\n\r\n(* this is how (multi-line) comments work,\r\n   blablabla\r\n*)\r\n \r\nend','tutorial','theory Submission\r\n  imports Defs\r\nbegin\r\n\r\n(* this is the submission file, \r\n   that\'s the file you should edit, and the place where you should compose the proofs that we\r\n   asked for!\r\n\r\n*)\r\nend'),(4,'Booleans and Natural Numbers','2','<h2>In this task you will learn:</h2>\r\n<ul>\r\n<li>about Types, Terms and Formulas</li>\r\n<li>how to use Booleans, Natural Numbers, and Integers</li>\r\n<li>how to state <b>definitions</b> and <b>functions</b></li>\r\n</ul>\r\n\r\n\r\n\r\n\r\n<h2>Types, Terms and Formulas</h2>\r\n\r\nHOL is a typed logic whose type system resembles that of functional programming languages. Thus there are\r\n\r\n<ul>\r\n<li><b>base types</b>, in particular bool, the type of truth values, nat, the type of natural numbers, and int, the type of mathematical integers.</li>\r\n<li><b>type constructors</b>, in particular <i>list</i>, the type of lists, and <i>set</i>, the type of sets. Type constructors are written postfix, i.e., after their arguments. For example, <i>nat list</i> is the type of lists whose elements are natural numbers.</li>\r\n<li><b>function types</b>, denoted by \"=>\".</li>\r\n<li><b>type variables</b>, denoted by \'a, \'b, etc., like in ML.\r\n</ul>\r\n\r\nNote that <i>\'a => \'b list</i> means <i>\'a => (\'b list)</i>, not <i>(\'a => \'b) list</i>: postfix type constructors have precedence over \"=>\".\r\n<b>Terms</b> are formed as in functional programming by applying functions to arguments. If f is a function of type \"\'a => \'b\" and t is a term of type \'a then <i>f t</i> is a term of type \'b . We write <i>t :: \'b</i> to mean that term t has type \'a.\r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>There are many predefined infix symbols like + and <=. The name of the corresponding binary function is <i>op +</i>, not just +. That is, <i>x + y</i> is nice surface syntax (?syntactic sugar?) for <i>op + x y</i>.\r\n</td>\r\n</tr>\r\n</table>\r\n\r\n\r\nHOL also supports some basic constructs from functional programming:\r\n\r\n\r\n<center>\r\n<table>\r\n<tr><td>\r\n(if b then t1 else t2)\r\n(let x=t in u)\r\n(case t of pat1 => t1 | ... | patn => tn)\r\n</td>\r\n</tr></table></center>\r\n\r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>The above three constructs must always be enclosed in parentheses if they occur inside other constructs..\r\n</td>\r\n</tr>\r\n</table>\r\n\r\nTerms may also contain lambda-abstractions. For example, %x. x is the identity function.\r\n\r\n<ul>\r\n<li><b>Formulas</b> are terms of type bool. There are the basic constants True and False and the usual logical connectives (in decreasing order of precedence): ~, /\\, \\/, --></li>\r\n<li><b>Equality</b> is available in the form of the infix function = of type \'a => \'a => bool. It also works for formulas, where it means \"if and only if\".</li>\r\n<li><b>Quantifiers</b> are written !!x. P and ??x. P.</li>\r\n</ul>\r\n\r\n\r\nIsabelle automatically computes the type of each variable in a term. This is called type inference. Despite type inference, it is sometimes necessary to attach an explicit type constraint (or type annotation) to a variable or term. The syntax is t::\'a as in \"m + (n::nat)\". Type constraints may be needed to disambiguate terms involving overloaded functions such as +.\r\n\r\nFinally there are the universal quantifier V and the implication =>. They are part of the Isabelle framework, not the logic HOL. Logically, they agree with their HOL counterparts !! and -->, but operationally they behave differently. This will become clearer as we go along.\r\n\r\n<h2>Quotation Marks</h2>\r\nThe textual definition of a theory follows a fixed syntax with keywords like <b>begin</b> and <b>datatype</b>. Embedded in this syntax are the types and formulas of HOL. To distinguish the two levels, everything HOL-specific (terms and types) must be enclosed in quotation marks: \"...\". Quotation marks around a single\r\nidentifier can be dropped. When Isabelle prints a syntax error message, it refers to the HOL syntax as the <b>inner syntax</b> and the enclosing theory language as the\r\n<b>outer syntax</b>.\r\n\r\n\r\n\r\n<h2>Type <i>bool</i></h2>\r\n\r\nThe type of boolean values is a predefined datatype\r\n\r\n<b>datatype</b> bool = True | False\r\n\r\nwith the two values True and False and with many predefined functions: ~, /\\, \\/, -->, etc. Here is how conjunction could be defined by pattern matching:\r\n\r\nfun conj :: \"bool => bool => bool\" where\r\n \"conj True True = True\"\r\n| \"conj _ _ = False\"\r\n\r\nBoth the datatype and function definitions roughly follow the syntax of functional programming languages\r\n\r\n\r\n<h2>Type <i>nat</i></h2>\r\n\r\nNatural numbers are another predefined datatype:\r\n<b>datatype</b> nat = 0 | Suc nat\r\n\r\nAll values of type <i>nat</i> are generated by the constructors 0 and Suc. Thus the values of type nat are: 0, Suc 0, Suc (Suc 0), etc. There are many predefined functions: +, *, <=, etc. Here is how you could define your own addition:\r\n\r\nfun add :: \"nat => nat => nat\" where\r\n\"add 0 n = n\" |\r\n\"add (Suc m) n = Suc (add m n)\"\r\n\r\n\r\n<h2>thm and value</h2>\r\n\r\nThere are two key words that can be used to gain information about what we already defined.\r\n\r\n<b>thm</b> <i>theoremname</i>, gives you the statement of some theorems. For example after defineing add as above the theorems named <i>add.simps</i> are available.\r\nUsing <b>thm</b> <i>add.simps</i> you can display them. Bring your cursor on the thm command and look into the output panel in order to find the statements of the theorems. You should see two equalities, one for each pattern of the add function.\r\n\r\n<b>value</b> <i>\"some term\"</i>, calculates the value of some term. E.g. you could ask for <b>value</b> <i>\"add (Suc 0) (Suc 0)\"</i>\". Again bring the focus on that expression and see the output panel for the value that could be determined for that term. See the submission template for some examples.\r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>Note that value only uses a specific set of equalities in order to determine a term\'s value. e.g. it will not unfold definitions, which we introduce in the next section! The set of equalities, value uses, will be specified later in the tutorial.\r\n</td>\r\n</tr>\r\n</table>\r\n\r\n<h2>Definitions and Function definitions</h2>\r\n\r\nNon-recursive functions can be defined as in the following example:\r\n\r\ndefinition sq :: \"nat => nat\" where \"sq n = n * n\"\r\n\r\nAfter the definition of a constant <i>name</i> the theorem <i>name_def</i> will hold the defining equation. You can display it by <b>thm</b> <i>name_def</i>.\r\n\r\n\r\n<h2>Theorem and proof</h2>\r\n\r\nNow lets turn to some theorems and prove them. Here is some easy example:\r\n\r\n<b>theorem</b> <i>myfirsttheorem:</i> \"conj True False = False\"\r\nby simp\r\n\r\nWe start an theorem by the keyword <b>theorem</b>, followed by some optional name and the theorem\'s statement. \r\nAfter that we have to justify why the lemma holds, we have to prove it. There are many ways of proving stuff, one way is using the\r\nsimplifier. This is a proof tactic which uses rewrite rules (e.g. the conj.simps are amongst them) in order to simplify statements \r\nuntil they are trivially True. Here to prove this theorem, the simplifier only has to use the definition of conj once for finding the correct\r\nproof. But <i>simp</i> is a real powerful tool!\r\n\r\nAfer you have proven a theorem, you can display it with the <b>thm</b> command:\r\n\r\n<b>thm</b> myfirsttheorem\r\n\r\nA theorem has the following outer syntax:\r\n\r\n<b>(theorem|lemma)</b> [<i>name:</i>] \"statement\"\r\n<b><i>someproof</i></b>\r\n\r\nHere is another example:\r\n\r\n<b>theorem</b> <i>mysecondtheorem:</i> \"sq 1 2 = 5\"\r\nunfolding sq_def by simp\r\n\r\nNote that the simplifier will not unfold definitions. This can be forced by <i>unfolding</i> the definition sq_def on our own. \r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>When you develop a proof, you can always look what is left to prove at the moment, i.e. display the current proof obligations. To do that, bring your cursor on the statement of the theorem, and then further to the back of the proof, you will see the goal statement evolve either in the <i>state</i> panel, or in the <i>output</i> panel (if you ticked the box \"Proof state\").\r\n</td>\r\n</tr>\r\n</table>\r\n\r\n\r\n<h2>sorry</h2>\r\n\r\nIf you want to postpone to provide a proof for some theorem you could just write <i>sorry</i>. This command will tell Isabelle that you cannot give a proof at the moment, but enables you to use theorem later in some other proof. This is a nice way of working: you can formulate some lemmas, mark them with sorry, and use them to show some theorem. Later you return to the lemmas and give a proof for them. An example:\r\n\r\n<b>lemma</b> <i>wouldliketoprovethat:</i> \"P = NP\"\r\nsorry\r\n\r\nBut beware, maybe the lemma is not correct. You could build upon a contradiction, which will invalidate all your further derivations. This is why you are not allowed to use sorry in a submission. So you are allowed to use sorry while developing your submission, but not when submitting. You can see a sorry in the template submission of this task, it will indicate where some work is left to you as a task.\r\n\r\n\r\n\r\n<h2>It\'s your turn</h2>\r\n \r\nThis lessons task is to prove the lemma helloworld. Look at the definitions of hello and world and then get rid of the sorry by providing a proof.\r\n\r\n','theory Check\r\nimports Submission\r\nbegin\r\n\r\n\r\ntheorem helloworld: \"hello world\"\r\nby (rule Submission.helloworld)\r\n   \r\n\r\nend','theory Defs\r\n  imports Main\r\nbegin\r\n\r\ndefinition world :: nat where \"world == Suc 0\"\r\n\r\nfun hello :: \"nat &#8658; bool\" where\r\n  \"hello 0 = False\"\r\n| \"hello (Suc n) = True\"\r\n  \r\n(* test *)  \r\n  \r\nend','tutorial','theory Submission\r\n  imports Defs\r\nbegin\r\n\r\n\r\nthm world_def\r\nthm hello.simps\r\n                     \r\nvalue \"hello 0\"\r\nvalue \"hello (Suc n)\"\r\nvalue \"world\"  (* the definition of world will not be unfolded automatically! *)\r\nvalue \"1 + 1\"  (* it is ambiguous what 1, and plus means, that\'s why no value could be determined *)\r\nvalue \"1 + (1::nat)\" (* when annotateing the type nat, the result can be determined *)\r\n\r\n\r\nlemma helloworld: \"hello world\" sorry\r\n\r\nend'),(5,'mod9','mod9','In this task you have to do some crazy stuff!','Check','Definition','helloworld','Submission'),(6,'name2','A - howto','Rev! In this task you have to do some real stuff!','Check2','Definition2','helloworld','Submission'),(7,'Induction','3','<h2>In this task you will learn</h2>\r\n<ul>\r\n<li>how to write proofs by induction in Isabelle</li>\r\n<li>about the outer syntax of proofs</li>\r\n<li>...</li>\r\n</ul>\r\n\r\n\r\n\r\n\r\n<h2>Induction on natural numbers</h2>\r\n\r\nAs stated in the lesson before, you can think of the natural numbers as of a recursive datatype:\r\n\r\n<b>datatype</b> nat = 0 | Suc nat\r\n\r\nFor datatypes like that, induction principles are automatically generated by Isabelle:\r\n\r\nlets look at:\r\n\r\n<b>thm</b> nat.induct\r\n\r\nThe output of thm will yield:\r\n\r\n?P 0 &#10233; (&#8896;nat. ?P nat &#10233; ?P (Suc nat)) &#10233; ?P ?nat\r\n\r\nThis means: in order to prove that P n holds, you have to prove that P 0 holds, and for any natural number n, if P n holds then also P (Suc n) holds. This should look familiar to you. Well it is just the induction principle for natural numbers.\r\n\r\nSo lets use it!\r\n\r\n<h2>An induction example</h2>\r\n\r\nIn the last section we defined a recursive version of addition of natural numbers:\r\n\r\nfun add :: \"nat => nat => nat\" where\r\n\"add 0 n = n\" |\r\n\"add (Suc m) n = Suc (add m n)\"\r\n\r\nThe lemma \"add 0 m = m\" is trivial. But what about \"add m 0 = m\"? Here is a proof that uses induction:\r\n\r\n<b>lemma</b> add_02: \"add m 0 = m\"\r\n<b>apply</b>(induction m) <b>apply</b>(auto) <b>done</b>\r\n\r\nThe <b>lemma</b> command starts the proof and gives the lemma a name, add_02. Properties of recursively defined functions need to be established by induction in most cases. Command <b>apply</b>(induction m) instructs Isabelle to start a proof by induction on m. In response, it will show the following proof state:\r\n<table>\r\n<tr>\r\n<td>1. add 0 0 = 0\r\n 2. !!m. add m 0 = m ==> add (Suc m) 0 = Suc m\r\n</td>\r\n</tr>\r\n</table>\r\n\r\nThe numbered lines are known as <i>subgoals</i>. The first subgoal is the base case, the second one the induction step. The prefix !!m. is Isabelle\'s way of saying \"for anarbitrary but fixed m\". The ==> separates assumptions from the conclusion. The command <b>apply(auto)</b> instructs Isabelle to try and prove all subgoals automatically, essentially by simplifying them. Because both subgoals are easy, Isabelle can do it.\r\n\r\nThe base case <i>add</i> 0 0 = 0 holds by definition of <i>add</i>, and the induction step is almost as simple: <i>add</i> (Suc m) 0 = Suc (add m 0) = Suc m using first the definition of <i>add</i> and then the indiction hypothesis. In summary, both subproofs rely on simplification with function definitions and the induction hypothesis. As a result of the final <b>done</b>, Isabelle associates the lemma just proven with its name. \r\n \r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>We have seen the proof command <b>by</b> simp in the previous section. Note that <b>by</b> X is just a shortform of <b>apply</b> X <b>done</b>, for finishing a proof! Where the proof tactic <i>simp</i> is only applied to the first subgoal, <i>auto</i> works on all subgoals. <i>auto</i> essentially does simplification (as simp does) plus some more. You will shortly learn more about that.\r\n</td>\r\n</tr>\r\n</table>\r\n\r\nYou can now inspect the lemma with the command\r\n\r\n<b>thm</b> add_02\r\n\r\nwhich displays:\r\n\r\n<i>add ?m 0 = ?m</i>\r\n\r\nThe free variable <i>m</i> has been replaced by the unknown <i>?m</i>. There is no logical difference between the two but there is an operational one: unknowns can be instantiated, which is what you want after some lemma has been proved.\r\nNote that there is also a proof method <i>induct</i>, which behaves almost like induction; the difference will be explained later.\r\n\r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>Terminology: We use <b>lemma</b>, <b>theorem</b> and <b>rule</b> interchangeably for propositions that have been proved.\r\n</td>\r\n</tr>\r\n</table>\r\n\r\n\r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>Numerals (0, 1, 2, ...) and most of the standard arithmetic operations (+, -, *, <=, <, etc.) are overloaded: they are available not just for natural numbers but for other types as well. For example, given the goal \"x + 0 = x\", there is nothing\r\nto indicate that you are talking about natural numbers. Hence Isabelle can only infer that x is of some arbitrary type where 0 and + exist. As a consequence, you will be unable to prove the goal. In this particular example, you need to include an explicit type constraint, for example \"x+0 = (x::nat)\". If there is enough contextual information this may not be necessary:\r\n\"Suc x = x\" automatically implies x::nat because Suc is not overloaded.\r\n</td>\r\n</tr>\r\n</table>\r\n\r\n<h2>An informal proof</h2>\r\n\r\nAbove we gave some terse informal explanation of the proof of \"add m 0 = m\".\r\nA more detailed informal exposition of the lemma might look like this:\r\n\r\n<b>Lemma</b> \"add m 0 = m\"\r\n<b>Proof</b> by induction on <i>m</i>.\r\n<ul>\r\n<li>Case <i>0</i> (the base case): add 0 0 = 0 holds by definition of add.</li>\r\n<li>Case <i>Suc m</i> (the induction step): We assume add m 0 = m, the induction hypothesis (IH), and we need to show add (Suc m) 0 = Suc m.\r\nThe proof is as follows:\r\n<table><tr><td>add (Suc m) 0</td><td> = Suc (add m 0) by definition of add</td></tr>\r\n       <tr><td></td><td> = Suc m by <b>IH</b></td></tr></table>\r\n</li>\r\n</ul>\r\n\r\nThroughout this book, <b>IH</b> will stand for \"induction hypothesis\".\r\n\r\n<h2>Granularity of Proofs</h2>\r\n\r\nWe have now seen three proofs of add m 0 = 0: the Isabelle one, the terse four lines explaining the base case and the induction step, and just now a model of a traditional inductive proof. The three proofs differ in the level of detail given and the intended reader: the Isabelle proof is for the machine, the informal proofs are for humans. Although this tutorial concentrates on Isabelle proofs, it is important to be able to rephrase those proofs as informal text comprehensible to a reader familiar with traditional mathematical proofs. Later on we will introduce an Isabelle proof language that is closer to traditional informal mathematical language and is often directly readable.\r\n\r\n\r\n<h2>Your Task</h2>\r\n\r\nCan you prove the more general theorem \"add n m = n + m\"?\r\n\r\n\r\n','theory Check\r\nimports Submission\r\nbegin\r\n\r\nlemma \"add n m = n + m\"\r\napply(rule Submission.add_nm) done\r\n\r\n\r\n\r\nend','theory Defs\r\n  imports Main\r\nbegin\r\nlemma hello: \"True\" by simp\r\n\r\n\r\nfun add :: \"nat => nat => nat\" where\r\n\"add 0 n = n\" |\r\n\"add (Suc m) n = Suc (add m n)\"\r\n\r\nend','tutorial','theory Submission\r\n  imports Defs\r\nbegin\r\n\r\n\r\nthm nat.induct\r\n\r\nlemma \"add m 0 = m\"\r\napply(induct m) by (auto)\r\n\r\nlemma add_nm: \"add n m = n + m\"\r\nsorry\r\n\r\n\r\n\r\nend'),(8,'Add is commutative','4','<h2>Your exercise</h2>\r\n\r\nWe just defined our own addition function\r\n\r\n\r\nfun add :: \"nat => nat => nat\" where\r\n\"add 0 n = n\" |\r\n\"add (Suc m) n = Suc (add m n)\"\r\n\r\n\r\nProve that it is commutative, i.e.\r\n\r\n<b>lemma</b> add_commutes: \"add n m = add m n\"\r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>\r\nIf you want to do the challenge on your on, continue without reading the next section!\r\n</td>\r\n</tr>\r\n</table>\r\n\r\n<h2>Some tipps</h2>\r\n\r\nLets look at the theorem statement, and try some stupid things: we could just apply auto and hope that Isabelle does the job for us. Unfortunatelly it doesnt. We already learned, that theorems about recursive functions mostly can be shown by induction. Lets try it:\r\n\r\n<b>theorem</b> add_commutes: \"add n m = add m n\"\r\n<b>apply(induction n)</b>\r\n\r\nWe are left with:\r\n 1. add 0 m = add m 0\r\n 2. !!n. add n m = add m n ==> add (Suc n) m = add m (Suc n)\r\n\r\nWell, the first one looks easy, doesn\'t it. \r\n\r\nLet\'s try simp on it:\r\n\r\n<b>apply</b> simp\r\n\r\n 1. m = add m 0\r\n\r\nAh well, we already proved the lemma before, only its symmetric version \"add m 0 = m\". We can reuse the lemma <i>add_m0</i> of the last section, lets copy it into our theory somewhere before the theorem we are currently working on!\r\n\r\nwe use\r\n\r\n<b>apply</b> (simp add: add_m0)\r\n\r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>\r\n(simp add: X Y) instructs the simplifier to also use the theorem X and Y while simplifying. That we are currently working on some lemmas talking about addition has nothing to do with the flag \"add:\", it justs adds more equations to the simplification rules.</td>\r\n</tr>\r\n</table>\r\n\r\nNow this leaves us with the induction step:\r\n\r\n 1. !!n. add n m = add m n ==> add (Suc n) m = add m (Suc n)\r\n\r\nlets use simp on it:\r\n\r\n\r\n<b>apply</b> simp\r\n\r\nleaves us with: \r\n\r\n 1. !!n. add n m = add m n ==> Suc (add m n) = add m (Suc n)\r\n\r\nWhat did just happen? Well on the left hand side of the equation the definition of add has been applied. Can we use the induction hypothesis? Well no. What is left to prove seems to be some lemma concerning the behaviour of Suc and add, lets look at it on its own:\r\n\r\n<b>lemma</b> Suc_add: \"add (Suc n) m = add m (Suc n)\"\r\nsorry\r\n\r\nLets not work on that, but first finish our first theorem.\r\n\r\nWe can instruct the simplifier to also use the lemma <i>Suc_add</i>, by: \r\n\r\n\r\n<b>apply</b> (simp add: Suc_add)\r\n\r\n\r\nEt voila:\r\n\r\n<b>No subgoals!</b>\r\n\r\nI leave proving the lemma <i>Suc_add</i>, we used, to you! Maybe it also will require induction?! ;)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','theory Check\r\nimports Submission\r\nbegin\r\n\r\nlemma \"add n m = add m n\"\r\napply(rule Submission.add_commutes) done\r\n\r\n\r\n\r\nend','theory Defs\r\n  imports Main\r\nbegin\r\nlemma hello: \"True\" by simp\r\n\r\n\r\nfun add :: \"nat => nat => nat\" where\r\n\"add 0 n = n\" |\r\n\"add (Suc m) n = Suc (add m n)\"\r\n\r\nend','tutorial','theory Submission\r\n  imports Defs\r\nbegin\r\n\r\n\r\nthm nat.induct\r\n\r\nlemma add_m0: \"add m 0 = m\"\r\napply(induct m) by (auto)\r\n \r\nlemma Suc_add: \"Suc (add m n) = add m (Suc n)\"\r\nsorry\r\n\r\nlemma add_commutes: \"add n m = add m n\"\r\nsorry\r\n\r\n\r\nend'),(9,'Type List','5','<h2>In this task you will learn</h2>\r\n<ul>\r\n<li>about the Type list</li>\r\n<li>how to prove things about it</li>\r\n<li>how to do structural induction on lists</li>\r\n</ul>\r\n\r\n\r\n\r\n\r\n<h2>The Type <i>lists</i></h2>\r\n\r\nAlthough lists are already predefined, we define our own copy for demonstration purposes:\r\n\r\n\r\n<b>datatype</b> \'a list = Nil | Cons \'a \"\'a list\"\r\n\r\n<ul>\r\n<li>Type <i>\'a list</i> is the type of lists over elements of type \'a.  Because \'a os a type variable, lists are in fact <b>polymorphic</b>: the elements of a list can be of arbitrary type (but must all be of the same type!).</li>\r\n<li>Lists have two constructors: <i>Nil</i>, the empty list, and <i>Cons</i>, which puts anelement (of type \'a) in front of the list (of type \'a list). Hence all lists are of the form <i>Nil</i>, Cons x Nil, or Cons x (Cons y Nil), etc.</li>\r\n<li><b>datatype</b> requires no quotation marks on the left-hand side, but on the right-hand side each of the argument types of a constructor needs to beenclosed in quotation marks, unless it is just an identifier (e.g., nat or \'a).</li>\r\n</ul>\r\n\r\nWe also define two standard functions, append and reverse:\r\n\r\n<b>fun</b> app :: \"\'a list => \'a list => \'a list\" <b>where</b>\r\n\"app Nil ys = ys\"\r\n| \"app (Cons x xs) ys = Cons x (app xs ys)\"\r\n\r\n<b>fun</b> rev :: \"\'a list =>\'a list\" <b>where</b>\r\n\"rev Nil = Nil\" |\r\n\"rev (Cons x xs) = app (rev xs) (Cons x Nil)\"\r\n\r\nBy default, variables xs, ys and zs are of list type.\r\n\r\nCommand <b>value</b> value evaluates for example:\r\n\r\nvalue \"rev (Cons True (Cons False Nil))\"\r\n\r\nyields <i>Cons False (Cons True Nil)</i>. This works symbolically, too:\r\n\r\nvalue \"rev (a True (b False Nil))\"\r\n\r\nyields <i>Cons b (Cons a Nil))</i>\r\n\r\n\r\nTheory Def below shows the theory created so far. Because <i>list</i>, <i>Nil</i>, <i>Cons</i>, etc. are already predefined, Isabelle prints qualified (long) names when executing this theory, for example, Def.Nil instead of Nil.\r\nTo suppres the qualified names you can insert the command declare [[names_short]]. This is not recommended in general but is convenient for this unusual example.\r\n\r\n<h2>Structural Induction for Lists</h2>\r\n\r\nJust as for natural numbers, there is a proof principle of induction for lists. Induction over a list is essentially induction over the length of the list, although the lenght remains implicit. To prove that some property P holds for all lists xs, i.e. P xs, you need to prove\r\n\r\n<ol>\r\n<li> the base case P Nil and</li>\r\n<li>the inductive case P (Cons x xs) under the assumption P xs, for some arbitrary but fixed x and xs.</li>\r\n</ol>\r\n\r\nThis is often called <b>structural induction</b> for lists.\r\n\r\n\r\n<h2>The Proof Process</h2>\r\n\r\nWe will now demonstrate the typical proof process, which involves the formulation and proof of auxiliary lemmas. Our goal is to show that reversing a list twice produces the original list.\r\n\r\n<b>theorem</b> rev_rev [simp]: \"rev (rev xs) = xs\"\r\n\r\nCommands <b>theorem</b> and <b>lemma</b> are interchangeable and merely indicate the importance we attach to a proposition. Via the bracketed attribute <i>simp</i> we also tell Isabelle to make the eventual theorem a <b>simplification rule</b>: future proofs involving simplification will replace occurences of <i>rev (rev xs)</i> by <i>xs</i>. The proof is by induction:\r\n\r\n<b>apply</b>(induction xs)\r\n\r\nAs explained above, we obtain two subgoals, namely the base case (Nil) and the induction step (Cons):\r\n\r\n 1. rev (rev Nil) = Nil\r\n 2. !!x1 xs. rev (rev xs) = xs ==> rev (rev (Cons x1 xs)) = Cons x1 xs\r\n\r\nLet us try to solve both goals automatically:\r\n\r\napply(auto)\r\n\r\nSubgoal 1 is proved, and disappears; the simplified version of subgoal 2 becomes the new subgoal 1:\r\n\r\n\r\n 1. !!x1 xs. rev (rev xs) = xs ==> rev (app (rev xs) (Cons x1 Nil)) = Cons x1 xs\r\n\r\nIn order to simplify this subgoal further, a lemma suggests itself.\r\n\r\n\r\n<h2>A First Lemma</h2>\r\n\r\nWe insert the following lemma in front of the main theorem:\r\n\r\n<b>lemma</b> rev_app [simp]: \"rev (app xs ys) = app (rev ys) (rev xs)\"\r\n\r\n<table>\r\n<tr>\r\n<td><img src=\"img/Tipp.png\"></td>\r\n<td>Before starting to prove a lemma, it is a good idea to first check whether this lemma really helps you proving your original theorem. By putting sorry after lemma rev_app and processing the whole document you can see that rev_rev\'s proof is completed after using the auto tactic. This gives you evidence that you found the right lemma, and now can turn to actually proving it.</td>\r\n</tr>\r\n</table>\r\n\r\nFor rev_app there are two variables that we could induct on: xs and ys. Because app is defined by recursion on the first argument, xs is the correct one.\r\n\r\n<b>apply</b>(induction xs)\r\n\r\nThis time not even the base case is solved automatically:\r\n\r\n<b>apply</b>(auto)\r\n 1. rev ys = app (rev ys) Nil\r\n 2. !!x1 xs. rev (app xs ys) = app (rev ys) (rev xs) ==>\r\n             app (app (rev ys) (rev xs)) (Cons x1 Nil) = app (rev ys) (app (rev xs) (Cons x1 Nil))\r\n\r\nAgain we need to abandon this proof attempt and prove another simple lemma first.\r\n\r\n\r\n<h2>Two more lemmas needed</h2>\r\n\r\nlemma app_Nil2 [simp]: \"app xs Nil = xs\"\r\n\r\nproving it, is left to you this time. But suppose we did find a proof, we can turn to the prove of rev_app. We find that this time auto solves the base case, but the induction step merely simplifies to:\r\n\r\n\r\n 1. !!x1 xs. rev (app xs ys) = app (rev ys) (rev xs) ==>\r\n             app (app (rev ys) (rev xs)) (Cons x1 Nil) = app (rev ys) (app (rev xs) (Cons x1 Nil))\r\n\r\nThe missing lemma is associativity of app, which we insert in the front of the failed lemma rev_app.\r\n\r\nlemma app_assoc [simp]: \"app (app xs ys) zs = app xs (app ys zs)\"\r\n\r\nis left to you. Finally the proofs of rev_app and rev_rev succeed, too.\r\n\r\n<h2>Now its your turn</h2>\r\n\r\nWe set out to prove that invoking rev twice returns the original list, i.e.\r\n\r\n<b>theorem</b> rev_rev [simp]: \"rev (rev xs) = xs\"\r\n\r\nWe already did some great work, but there are still two holes in our proof. Can you fill them in?\r\n\r\n\r\n\r\n\r\n\r\n','theory Check\r\nimports Submission\r\nbegin\r\n\r\n                     \r\ntheorem \"Defs.rev (Defs.rev xs) = xs\"\r\nby (rule Submission.doublerev)\r\n  \r\n\r\n\r\nend','theory Defs\r\n  imports Main\r\nbegin\r\nlemma hello: \"True\" by simp\r\n\r\ndatatype \'a list = Nil | Cons \'a \"\'a list\"\r\n\r\nfun app :: \"\'a list => \'a list => \'a list\" where\r\n\"app Nil ys = ys\"\r\n| \"app (Cons x xs) ys = Cons x (app xs ys)\"\r\n\r\nfun rev :: \"\'a list =>\'a list\" where\r\n\"rev Nil = Nil\" |\r\n\"rev (Cons x xs) = app (rev xs) (Cons x Nil)\"\r\n\r\nlemma hello2: \"True\" by simp\r\n\r\nend','tutorial','theory Submission\r\n  imports Defs\r\nbegin\r\n\r\n\r\n  declare [[names_short]]\r\n  \r\n  \r\nlemma app_Nil2 [simp]: \"app xs Nil = xs\"\r\nsorry\r\n  \r\n\r\nlemma app_assoc [simp]: \"app (app xs ys) zs = app xs (app ys zs)\"\r\nsorry\r\n\r\nlemma rev_append [simp]: \"rev (app xs ys) = app (rev ys) (rev xs)\"\r\n  apply(induct xs) apply(auto) done\r\n  \r\nlemma doublerev: \"rev (rev xs) = xs\"\r\n  apply(induct xs) apply auto  done\r\n\r\n\r\nend'),(10,'More on Lists','6','<h2>Another Informal Proof on Lists</h2>\r\n\r\nYou just have proven the associativity of app in Isabelle. Here is the corresponding informal proof:\r\n\r\n<b>Lemma</b> app (app xs ys) zs = app xs (app ys zs)\r\n<b>Proof</b> by induction on xs.\r\n\r\n<ul>\r\n<li>Case Nil: app (app Nil xs) ys = <b>app ys zs</b> = app Nil (app ys zs) holds by definition of app.</li>\r\n<li>Case Cons x xs: We assume\r\napp (app xs ys) xs = app xs (app ys zs)  (<b>IH</b>)\r\nand we need to show\r\napp (app (Cons x xs) ys) zs = app (Cons x xs) (app ys zs).\r\n\r\nThe proof is as follows:\r\n<table>\r\n<tr> <td></td><td>app (app (Cons x xs) ys) zs </td><td>    </td><td></td></tr>\r\n<tr> <td>=</td><td>app (Cons x (app xs ys)) zs </td><td></td><td>by definition of app</td> </tr>\r\n<tr> <td>=</td><td>Cons x (app (app xs ys) zs) </td><td></td><td>by definition of app</td> </tr>\r\n<tr> <td>=</td><td><b>Cons x (app xs (app ys zs))</b> </td><td></td><td>by <b>IH</b></td> </tr>\r\n<tr> <td>=</td><td>app (Cons x xs) (app ys zs) </td><td></td><td>by definition of app</td> </tr>\r\n</table>\r\n</li>\r\n</ul>\r\n\r\n\r\n<b>Here is something to learn!</b>\r\n\r\nDidn\'t we say earlier that all proofs are by simpliciation? But in both cases, going from left to right, the last equality step is not a simplification at all!\r\n\r\nIn the base case it is \"app ys zs = app Nil (app ys zs)\". It appears almost mysterious because we suddenly complicate the term by appending Nil on the left.\r\n\r\nWhat is really going on is this: when proving some equality \"s = t\", both s and t are simplified until they \"meet in the middle\". This heuristic for equality proofs works well for a functional programming context like ours. In the base case both \"app (app Nil ys)\" and \"app Nil (app ys zs\" are simplified to \"app ys zs\", the term in the middle.\r\n\r\n\r\n\r\n<h2>Predefined Lists</h2>\r\n\r\nIsabelle\'s prefined lists are the same as the ones above, but with more syntactic sugar:\r\n\r\n<ul>\r\n<li>[] is Nil</li>\r\n<li>x#xs is Cons x xs</li>\r\n<li>[x1, x2, ... , xn] is x1 # x2 # ... # xn # [], and</li>\r\n<li>xs @ ys is app xs ys</li>\r\n</ul>\r\n\r\n\r\nThere is also a large library of predefined functions. The most important ones ar the length function \"length :: \'a list => nat\" (with the obvious definition), and the map function that applies a function to all elements of a list:\r\n\r\n<b>fun</b> map :: \"(\'a => \'b) => \'a list => \'b list\" where\r\n \"map f Nil = Nil\"\r\n|\"map f (Cons x xs) = Cons (f x) (map f xs)\"\r\n\r\nAlso useful are the head of a list, its first element, and the tail, the rest of the list:\r\n\r\n<b>fun</b> hd :: \"\'a list => \'a\" where\r\n\"hd (x # xs) = x\"\r\n\r\n<b>fun</b> tl :: \"\'a list => \'a list\" where\r\n\"tl (x # xs) = xs\"\r\n\r\nNote that since HOL is a logic of total functions, hd [] is defined, but wo do not know what the result is not know what the result is. That is, hd [] is not undefined but underdefined. From now on lists are always the predefined lists.\r\n\r\n\r\n<h2>Your Task</h2>\r\n\r\nProve the same result as you did in the last section for the standard lists.\r\n\r\nTo that end, define a function <i>rev</i> and show the lemma:\r\n\r\ntheorem doublerev: \"Submission.rev (Submission.rev xs) = xs\"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','theory Check\r\nimports Submission\r\nbegin\r\n\r\n                     \r\ntheorem \"Submission.rev (Submission.rev xs) = xs\"\r\nby (rule Submission.doublerev)\r\n  \r\n(* some sanity checks *)\r\n\r\ntheorem \"Submission.rev [1,2,3] = [3,2,1]\" by simp\r\n\r\n(* some more hidden sanity checks *) \r\n\r\n\r\nend','theory Defs\r\n  imports Main\r\nbegin\r\n\r\nlemma hello: \"True\" by simp \r\n\r\n\r\nend','tutorial','theory Submission\r\n  imports Defs\r\nbegin\r\n\r\n(*\r\nfun rev where\r\n  \r\n*)\r\n\r\n   \r\nlemma doublerev: \"rev (rev xs) = xs\"\r\nsorry\r\n\r\n\r\nend'),(11,'Count the length','7','Define a function <i>count :: \'a => \'a list => nat</i> that counts the number of occurences of an element in a list. Prove:\r\n\r\ntheorem count_ub: \"count x xs <= length xs\"','theory Check\r\nimports Submission\r\nbegin\r\n\r\n                     \r\nlemma count_ub: \"Submission.count x xs &#8804; length xs\" \r\nby (rule Submission.count_ub)\r\n  \r\n(* some sanity checks *)\r\n\r\ntheorem \"Submission.count 1 [1,1,1] = 3\" by auto\r\n\r\n(* some more hidden sanity checks *) \r\n\r\n(* ... *)\r\n\r\n\r\nend','theory Defs\r\n  imports Main\r\nbegin\r\nlemma hello: \"True\" by simp\r\n\r\n(* nothing to define! *)\r\nend','tutorial','theory Submission\r\n  imports Defs\r\nbegin\r\n\r\n(*\r\nfun count :: \"\'a => \'a list => nat\" where\r\n\r\n*)\r\n  \r\nlemma count_ub: \"count x xs &#8804; length xs\"\r\nsorry\r\n\r\n\r\nend'),(12,'Add is associative','8','Prove the function <i>add</i> to be associative.','theory Check\r\nimports Submission\r\nbegin\r\n                     \r\nlemma add_assoc: \"Defs.add (Defs.add x y) z= Defs.add x (Defs.add y z)\" \r\nby (rule Submission.add_assoc)\r\n\r\nend','theory Defs\r\n  imports Main\r\nbegin\r\n\r\nfun add :: \"nat => nat => nat\" where\r\n\"add 0 n = n\" |\r\n\"add (Suc m) n = Suc (add m n)\"\r\n\r\nend','tutorial','theory Submission\r\n  imports Defs\r\nbegin\r\n\r\nlemma add_assoc: \"add (add x y) z= add x (add y z)\"\r\n\r\nend');
/*!40000 ALTER TABLE `Task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `User`
--

DROP TABLE IF EXISTS `User`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `User` (
  `ID` int(64) NOT NULL AUTO_INCREMENT,
  `pwd` text,
  PRIMARY KEY (`ID`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `User`
--

LOCK TABLES `User` WRITE;
/*!40000 ALTER TABLE `User` DISABLE KEYS */;
/*!40000 ALTER TABLE `User` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-02-03 15:03:36
